@using CardGameWebApp.Shared.DTOs
@using CardGameWebApp.Shared.Inquiries
@using CardGameWebApp.Shared.Responses
@using System.Net
@using Microsoft.AspNetCore.SignalR.Client
@inject HttpClient Http

<SelectCardPrompt></SelectCardPrompt>

<!-- Player select -->
@if (players != null)
{
	<div class="btn-group" role="group">
	@for(int i = 0; i < players.Count; i++)
	{
		var playerIndex = i;
		<button type="button" class="btn @(players[playerIndex] ? "btn-primary" : "btn-outline-primary")" @onclick="@(() => TogglePlayer(playerIndex))" autocomplete="off">Player @(i+1)</button>
	}
	</div>
}

<!-- Community cards -->
@if (communities != null && communities.Any())
{
	<div>
		<h2>Community cards collections</h2>
	
	</div>
}

<!-- Decks -->

@if (decks != null && decks.Any())
{
	<div>
		<h2>Decks</h2>
	@foreach (var deck in decks.Select(d => collectionCache[d.Key]))
	{
		<Deck FaceUp="false" NumberOfCards="deck.CardCollection.CardCount" 
			Name="@deck.CardCollection.Name" Actions="() => GetActions(deck.CardCollection.Actions)">
			@if (deck.CardCollection.VisibleCards.Any())
			{
				@foreach (var card in deck.CardCollection.VisibleCards)
				{
					<Card Template="@card.Name" />
				}
			}
			else
			{
				<p>@deck.CardCollection.Name</p>		
			}
		</Deck>
	}
	</div>
}

<!-- Hands -->
@if (hands != null && hands.Any())
{
	<div>
		<h2>Hands</h2>
	@foreach (var hand in hands.Select(h => collectionCache[h.Key]))
	{
		<Hand NumberOfCards="hand.CardCollection.CardCount" FaceUp="true">
			@foreach (var card in hand.CardCollection.VisibleCards)
			{
				<Card Template="@card.Name" Actions="() => GetActions(card.Actions)" />
			}
		</Hand>
	}
	</div>
}

@code {
	private GameOverviewResponse game;
	private IEnumerable<string> communities = null;
	private IDictionary<string, string> hands = null;
	private IDictionary<string, string> decks = null;
	private Dictionary<string, CardCollectionResponse> collectionCache;
	private List<bool> players;
	private HubConnection? hubConnection;

	public async Task Start(string gameUrl)
	{
		collectionCache = new Dictionary<string, CardCollectionResponse>();
		players = new List<bool>();
		hands = null;
		decks = null;

		game = await Http.GetFromJsonAsync<GameOverviewResponse>(gameUrl);

		for(int i = 0; i < game.Game.NumberOfPlayers; i++)
		{
			players.Add(false);
		}
		hubConnection = new HubConnectionBuilder().WithUrl(game.Links["hub"]).Build();
		hubConnection.On<int>("PlayerJoined", (int i) =>
		{ 
			players[i] = true; 
			this.StateHasChanged();
		});
		hubConnection.On<int>("PlayerLeft", (int i) =>
		{ 
			players[i] = false; 
			this.StateHasChanged();
		});
		hubConnection.On("NewState", async () =>
		{ 
			await updateCache();
			this.StateHasChanged();
		});

		hubConnection.On<SelectCardInquiry>("SelectCard", async (inquirt) =>
		{
			
		});

		await hubConnection.StartAsync();
		await hubConnection.SendAsync("join", game.SessionId);

		foreach (var pair in game.Game.Hands)
			await UpdateCollectionCache(pair.Key, pair.Value);
		foreach (var pair in game.Game.Decks)
			await UpdateCollectionCache(pair.Key, pair.Value);

		hands = game.Game.Hands;
		decks = game.Game.Decks;
		this.StateHasChanged();
	}

	public async void Stop()
	{
		await hubConnection.SendAsync("leave", game.SessionId);
		await hubConnection.StopAsync();
	}

	private void TogglePlayer(int index)
	{
		if (!players[index])
			hubConnection.SendAsync("selectPlayer", game.SessionId, index);
		else
			hubConnection.SendAsync("ReleasePlayer", game.SessionId, index);
	}

	private async Task updateCache()
	{
		foreach (var pair in hands)
			await UpdateCollectionCache(pair.Key, pair.Value);
		foreach (var pair in decks)
			await UpdateCollectionCache(pair.Key, pair.Value);		
	}

	private async Task UpdateCollectionCache(string name, string url)
	{
		var response = await Http.GetFromJsonAsync<CardCollectionResponse>(url);
		if (collectionCache.ContainsKey(name))
			collectionCache[name] = response;
		else
			collectionCache.Add(name, response);
	}

	private IEnumerable<CallBackAction> GetActions(IDictionary<string, string> actions)
	{
		foreach (var action in actions)
		{
			yield return new CallBackAction
			{
				Name = action.Key,
				Execute = async () =>
				{
					Console.WriteLine($"Call {action.Value}");
					var actionReponse = await Http.GetFromJsonAsync<ActionResponse>(action.Value);
					var dto = actionReponse.Action;

					var response = Http.PostAsync(action.Value, JsonContent.Create(dto)).ContinueWith(async (response) =>
					{
						if (response.Result.StatusCode == HttpStatusCode.OK)
						{
							await updateCache();
							this.StateHasChanged();
						}
					});
				}
			};
		}
	}
}