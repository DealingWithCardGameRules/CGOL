@using CardGameWebApp.Shared.DTOs
@inject IJSRuntime JS
@inject HttpClient Http

<div class="mt-1">
    <nav class="navbar navbar-expand-lg navbar-dark bg-dark pb-0">
      <div class="container-fluid">
        <span class="navbar-brand">
            <i class="fa-solid fa-chess-board"></i>
        </span>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="navbarSupportedContent">
          <ul class="navbar-nav me-auto mb-2 mb-lg-0">
            <li class="nav-item dropdown">
              <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
                <i class="text-primary fa-solid fa-circle-exclamation"></i> 
                Commands
              </a>
              <ul class="dropdown-menu" aria-labelledby="navbarDropdown">
                @foreach (var command in highlighter.KnownConcept.Where(c => c.Value.Type.Equals(ConceptDTO.TYPE_COMMAND)))
                {
                    <li>
                        <a class="dropdown-item" @onclick="() => InsertTextAtCaret(command.Key)">@command.Key</a>
                    </li>    
                }
              </ul>
            </li>
            <li class="nav-item dropdown">
              <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
                <i class="text-info fa-solid fa-circle-question"></i> 
                Queries
              </a>
              <ul class="dropdown-menu" aria-labelledby="navbarDropdown">
                @foreach (var query in highlighter.KnownConcept.Where(c => !(c.Value.Type.Equals(ConceptDTO.TYPE_COMMAND) || c.Value.Type.Equals(ConceptDTO.TYPE_EVENT))))
                {
                    <li>
                        <a class="dropdown-item" @onclick="() => InsertTextAtCaret(query.Key)">
                            @query.Key
                        </a>
                    </li>    
                }
              </ul>
            </li>
            <li class="nav-item">
                <a class="nav-link">
                 Help
                </a>
            </li>
          </ul>
          <!--
          <form class="d-flex">
            <input class="form-control me-2" type="search" placeholder="Search" aria-label="Search">
            <button class="btn btn-outline-success" type="submit">Search</button>
          </form>
          -->
        </div>
      </div>
    </nav>

    <div class="highlight-editor">
        <textarea @ref="inputText" id="editing" class="editing @intel" wrap="off" spellcheck="false" value="@Value" @oninput="TextChanged" onscroll="sync_scroll();" @onkeydown="KeyDown" @onkeydown:preventDefault="@keyEventHandled" @onkeyup="Reset"></textarea>
        <pre id="highlighting" class="highlighting" aria-hidden="true" @onclick="Reset">
          <code class="language-cgdl">@((MarkupString)HighlightedCGDL)</code>
        </pre>
    </div>
</div>

@code {
    // Inspiration:
    // https://css-tricks.com/creating-an-editable-textarea-that-supports-syntax-highlighted-code/    

    private ElementReference inputText { get; set; }
    private Highlighter highlighter = new Highlighter();
    private string source = string.Empty;
    private string HighlightedCGDL;
    private string intel;
    private bool keyEventHandled = false;

    [Parameter]
    public Action OnCtrlS { get; set; }

    public bool HasChanges { get; set; } = false;

    private async Task KeyDown(KeyboardEventArgs args)
    {
        keyEventHandled = false;
        if (args.CtrlKey)
        {
            intel = "intel";
        }
        if (args.Key.Equals("Tab"))
        {
            keyEventHandled = true;
            await InsertTextAtCaret(highlighter.Suggestion ?? "\t");
        }
        if (args.CtrlKey && args.Key.Equals("s"))
        {
            keyEventHandled = true;
            if (OnCtrlS != null)
            {
                OnCtrlS.Invoke();
                HasChanges = false;
            }
        }
    }

    private async Task InsertTextAtCaret(string text)
    {
        var pos = await JS.InvokeAsync<int>("getSelectedStart", inputText);
        var start = Value.Substring(0, pos);
        var end = Value.Substring(pos);
        Value = $"{start}{text}{end}";
        this.StateHasChanged();
        await JS.InvokeVoidAsync("setCaret", inputText, pos + text.Length);
    }

    private void Reset()
    {
        intel = "";
    }

    public string Value
    {
        set
        {
            source = value;
            HighlightText();
        }
        get
        {
            return source;
        }
    }

    public void SetText(string cgd)
    {
        Value = cgd;
        HasChanges = false;
    }

    private async Task TextChanged(ChangeEventArgs args)
    {
        source = args.Value.ToString();
        await HighlightText();
        HasChanges = true;
    }

    private async Task HighlightText()
    {
        var pos = await JS.InvokeAsync<int>("getSelectedStart", inputText);
        HighlightedCGDL = Highlight(Value, pos);
        await JS.InvokeVoidAsync("sync_scroll");
        this.StateHasChanged();
    }

    public async Task UpdateConcepts(string url)
    {
        var concepts = await Http.GetFromJsonAsync<IEnumerable<ConceptDTO>>(url);
        var dict = new Dictionary<string, ConceptDTO>(StringComparer.OrdinalIgnoreCase);
        foreach (var concept in concepts)
        {
            dict[concept.Name] = concept;
        }
        highlighter.KnownConcept = dict;
        this.StateHasChanged();
    }


    private string Highlight(string input, int pos = 0)
    {
        return highlighter.Highlight(input, pos);
    }
}
